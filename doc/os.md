## OS methods and fields

Any method that fails will throw a runtime error with a message describing the error.

The following methods and fields are defined in the built-in `os` class:
- `os.argv`, which is a list containing the command line arguments passed to the current script
    - `os.argv[0]` contains the absolute path name of the executable for the current process as a string or an empty string if the path name cannot be determined
    - When executing a script from a file, `os.argv[1]` contains the name of the script file that is being executed
- `os.chdir(directory)`, which changes the current working directory to the specified directory string
- `os.chmod(path, mode)`, which changes the mode of the specified path string to `mode`
    - This method works on Windows, but only the read-only flag can be changed. Use mode `0400` to make the file read-only and `0600` to make it readable and writable
- `os.chown(path, uid, gid)`, which changes the uid and gid of the specified path string to `uid` and `gid`
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.chroot(path)`, which changes the root directory of the current process to the specified path string
    - This method does not work on Windows and throws an error if called on there
- `os.clearenv()`, which removes all environment variables from the current process
- `os.close(fd)`, which closes the specified integer file descriptor
- `os.copy(source, dest)`, which copies the file at the `source` path string to the destination specified by the path string `dest` and returns the total number of bytes copied
    - If the file at `source` doesn't exist or `source` refers to a directory, a runtime error is thrown
    - If `dest` refers to a directory, the file at `source` will be copied into the directory given by `dest` with the copied file having the same name as the source file's original name
- `os.dup(oldfd)`, which creates and returns a new file descriptor integer that refers to the file associated with `oldfd`, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.dup2(oldfd, newfd)`, which duplicates the file descriptor `oldfd` to the file descriptor `newfd`, closing `newfd` in the process, where `oldfd` and `newfd` are both integers, and returns the value of `newfd` as an integer
    - If `oldfd == newfd` and `oldfd` is a valid file descriptor, this function does nothing and simply returns the value of `newfd` as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.execl(path, arg1, [arg2, ..., argN])`, which executes the program given by the string argument `path` and the arguments from `arg1` to `argN`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `path`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` are optional
    - This method does not work on Windows and throws an error if called on there
- `os.execle(path, arg1, [arg2, ..., argN], envp)`, which executes the program given by the string argument `path`, the arguments from `arg1` to `argN`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `path` other than `envp`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` except for `envp` are optional
    - This method does not work on Windows and throws an error if called on there
- `os.execlp(file, arg1, [arg2, ..., argN])`, which executes the program given by the string argument `file` and the arguments from `arg1` to `argN`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `file`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` are optional
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.execlpe(file, arg1, [arg2, ..., argN], envp)`, which executes the program given by the string argument `file`, the arguments from `arg1` to `argN`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `file` other than `envp`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` except for `envp` are optional
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.executable()`, which returns the absolute path name of the executable for the current process as a string
- `os.execv(path, argv)`, which executes the program given by the string argument `path` and the list argument `argv`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.execve(path, argv, envp)`, which executes the program given by the string argument `path`, the list argument `argv`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.execvp(file, argv)`, which executes the program given by the string argument `file` and the list argument `argv`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.execvpe(file, argv, envp)`, which executes the program given by the string argument `file`, the list argument `argv`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.expandEnv(string)`, which returns a new string with all occurrences of `$var` and `${var}` in `string` replaced with the value of `var` itself, where `var` is an environment variable
    - If `var` is not an environment variable, it is replaced with an empty string
- `os.expandHome(string)`, which returns a new string with the characters `~` or `~/` at the beginning of the original string replaced with the path of the user's home directory
    - This method uses the value of the `HOME` environment variable as the home directory on non-Windows systems if it exists
- `os.exit([code])`, which exits the program with the specified exit code. If `code` is omitted, the default exit code is 0
    - Calling this method will immediately stop the program without running any other code, e.g., if this method is called inside a try-catch block with a `finally` block, the `finally` block will not be executed
- `os.fchdir(fd)`, which changes the current working directory to the specified directory file descriptor
    - This method does not work on Windows and throws an error if called on there
- `os.fchmod(fd, mode)`, which changes the mode of the specified file descriptor to `mode`
    - This method does not work on Windows and throws an error if called on there
- `os.fchown(fd, uid, gid)`, which changes the uid and gid of the specified file descriptor to `uid` and `gid`
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.fsync(fd)`, which forces a write of the file with the specified file descriptor to disk
- `os.ftruncate(fd, size)`, which changes the size of the file specified by the file descriptor integer to `size` bytes specified as an integer
    - If `size` is less than the file size in bytes, the extra data is lost
    - If `size` is greater than the file size in bytes, the file is extended with null bytes until it is equal to `size` bytes
- `os.getcwd()`, which returns the current working directory as a string
- `os.getegid()`, which returns the effective group ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getenv(key, [default])`, which returns the value of the specified environment variable `key`, which is a string, as a string. If the value doesn't exist, the value of `default` is returned if specified, otherwise `nil` is returned
- `os.getenvs()`, which returns a dictionary with all environment variable keys as dictionary keys and all environment variable values as dictionary values
- `os.geteuid()`, which returns the effective user ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getgid()`, which returns the group ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getgroups()`, which returns a list of the supplementary group IDs of the current process as integers
    - This method does not work on Windows and throws an error if called on there
- `os.getpid()`, which returns the process ID of the current process as an integer
- `os.getppid()`, which returns the process ID of the parent process as an integer
- `os.getuid()`, which returns the user ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.hostname()`, which returns the hostname of the computer as a string
- `os.isatty(fd)`, which returns `true` if the specified integer file descriptor is open and refers to a terminal and `false` otherwise
- `os.kill(pid, [signalNum])`, which sends the signal corresponding to the integer `signalNum` to the process corresponding to `pid`, which is the process ID as an integer. If `signalNum` is omitted, this method kills the process corresponding to `pid` without letting it terminate gracefully
- `os.lchown(path, uid, gid)`, which changes the uid and gid of the specified path string to `uid` and `gid`
    - If `path` refers to a symbolic link, the uid and gid of the link itself is changed
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.link(target, linkName)`, which creates a hard link to `target` with the name `linkName`, which are both strings
- `os.listdir([path])`, which returns a list of names of all directories and files in the specified path as strings. If `path` is omitted, the current working directory is used as the path
- `os.mkdir(name)`, which creates a new directory with the specified name in the current working directory
- `os.mkdirp(path)`, which creates a new directory with the specified path name along with any necessary parent directories
- `os.mkfifo(name)`, which creates a FIFO (named pipe) with the specified name in the current working directory
    - This method does not work on Windows and throws an error if called on there
- `os.mktemp([directory])`, which creates a temporary file with the name `lox.tmp.` followed by a random number in the specified directory and returns a file object open in read-write mode if successful. If the directory is omitted, the temporary file is created in the default temporary file directory of the operating system
    - Any temporary files created using this method must be manually deleted, which can be done with the following method call: `os.remove(tempFile.name)`, where `tempFile` is the variable that refers to the temporary file's file object
- `os.mktempBin([directory])`, which creates a temporary file with the name `lox.tmp.` followed by a random number in the specified directory and returns a file object open in read-write binary mode if successful. If the directory is omitted, the temporary file is created in the default temporary file directory of the operating system
    - Any temporary files created using this method must be manually deleted, which can be done with the following method call: `os.remove(tempFile.name)`, where `tempFile` is the variable that refers to the temporary file's file object
- `os.name`, which is a string that specifies the operating system that the program is running on
- `os.open(name, mode)`, which opens a file specified by a path name with the mode specified by the mode string. This method returns a file object if successful, which itself is documented [here](./doc/file.md)
    - The following file modes are available:
        - `"r"`, which opens a file for reading and throws a runtime error if the file doesn't exist
        - `"w"`, which opens a file for writing, creating the file if it doesn't exist and truncating the file if it already exists
        - `"a"`, which opens a file for writing, creating the file if it doesn't exist and appending to the file if it already exists
        - Along with the above modes, the letter `"b"` can also be specified to open a file in binary mode, such as `"rb"` for reading a binary file
            - The ordering doesn't matter, so the mode `"br"` is the same as `"rb"`
- `os.pipe()`, which returns a list containing two file objects in text mode that are connected to each other through a pipe, where reading from the read end returns data that is written to the write end
    - `list[0]` and `list[1]` contains the read and write ends of the pipe respectively
- `os.pipeBin()`, which returns a list containing two file objects in binary mode that are connected to each other through a pipe, where reading from the read end returns data that is written to the write end
    - `list[0]` and `list[1]` contains the read and write ends of the pipe respectively
- `os.read(fd, numBytes)`, which reads at most `numBytes` bytes from the specified integer file descriptor into a buffer and returns that buffer
- `os.readFile(name)`, which reads in the contents of the file with the specified file name string and returns a string with the file contents
- `os.readFileBin(name)`, which reads in the contents of the file with the specified file name string and returns a buffer with the file contents
- `os.readLink(name)`, which returns a string representing the destination of the symbolic link with the specified symbolic link name string
- `os.remove(path)`, which removes the file or empty directory at the specified path string
    - If the directory is not empty, a runtime error is thrown
- `os.removeAll(path)`, which removes the file or directory at the specified path string
    - If the directory is not empty, all files and directories inside it are removed recursively
- `os.rename(oldPath, newPath)`, which renames the file at `oldPath` to the name specified by `newPath`, which are both strings. If a file at `newPath` already exists and is not a directory, it is replaced with the file at `oldPath`
- `os.SEEK_SET`, `os.SEEK_CUR`, and `os.SEEK_END`, which are all integer values representing the seek mode for the `file.seek` method
- `os.setegid(egid)`, which sets the effective group ID of the current process to the specified effective group ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setenv(key, value)`, which sets an environment variable with the specified key and value, which are both strings
- `os.seteuid(euid)`, which sets the effective user ID of the current process to the specified effective user ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setgid(gid)`, which sets the group ID of the current process to the specified group ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setgroups(gids)`, which sets the supplementary group IDs for the current process to the values in `gids`, which must be an empty list or a list of integers
    - This method does not work on Windows and throws an error if called on there
- `os.setregid(rgid, egid)`, which sets the group ID and effective group ID of the current process to the specified group ID and effective group ID, which are both integers
    - Passing in `-1` for `rgid` or `egid` will result in the group ID or the effective group ID being unchanged respectively
    - This method does not work on Windows and throws an error if called on there
- `os.setresgid(rgid, egid, sgid)`, which sets the group ID, effective group ID, and saved group ID of the current process to the specified group ID, effective group ID, and saved group ID, which are all integers
    - Passing in `-1` for `rgid`, `egid`, or `sgid` will result in the group ID, the effective group ID, or the saved group ID being unchanged respectively
    - This method only works on Linux and throws an error if called on any other operating system
- `os.setresuid(ruid, euid, suid)`, which sets the user ID, effective user ID, and saved user ID of the current process to the specified user ID, effective user ID, and saved user ID, which are all integers
    - Passing in `-1` for `ruid`, `euid`, or `suid` will result in the user ID, the effective user ID, or the saved user ID being unchanged respectively
    - This method only works on Linux and throws an error if called on any other operating system
- `os.setreuid(ruid, euid)`, which sets the user ID and effective user ID of the current process to the specified user ID and effective user ID, which are both integers
    - Passing in `-1` for `ruid` or `euid` will result in the user ID or the effective user ID being unchanged respectively
    - This method does not work on Windows and throws an error if called on there
- `os.setuid(uid)`, which sets the user ID of the current process to the specified user ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.stderr`, which is a file object that allows for writing text to the standard error stream
- `os.stdin`, which is a file object that allows for reading text from the standard input stream
- `os.stdout`, which is a file object that allows for writing text to the standard output stream
- `os.stderrBin`, which is a file object that allows for writing binary data to the standard error stream
- `os.stdinBin`, which is a file object that allows for reading binary data from the standard input stream
- `os.stdoutBin`, which is a file object that allows for writing binary data to the standard output stream
- `os.symlink(target, linkName)`, which creates a symbolic link to `target` with the name `linkName`, which are both strings
- `os.sync()`, which forces a write of all data to disk
    - This method does not work on Windows and throws an error if called on there
- `os.system(command)`, which runs the specified command string in the system shell, which is `sh` on Unix and `cmd` on Windows, and returns the exit code of the command as an integer
- `os.tempdir()`, which returns the path of the default temporary file directory of the operating system as a string
- `os.touch(name)`, which creates a new empty file with the specified name in the current working directory
    - If the file already exists, it is truncated
- `os.truncate(path, size)`, which changes the size of the file specified by the path string to `size` bytes specified as an integer
    - If `size` is less than the file size in bytes, the extra data is lost
    - If `size` is greater than the file size in bytes, the file is extended with null bytes until it is equal to `size` bytes
- `os.umask(mask)`, which sets the current umask value to the integer `mask` and returns the previous umask value as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.uname()`, which returns a dictionary containing information about the current Unix operating system
    - The returned dictionary contains the following keys and values, which are all strings:
        - `sysname`: name of the operating system
        - `nodename`: name of the current machine on the network
        - `release`: release of the operating system
        - `version`: version of the operating system
        - `machine`: architecture of the current machine
    - This method does not work on Windows and throws an error if called on there
- `os.unsetenv(key)`, which unsets the environment variable `key`, which is a string
- `os.urandom(size)`, which returns a buffer of `size` random bytes that are cryptographically secure, where `size` is an integer
    - If `size` is negative, a runtime error is thrown
- `os.username()`, which returns the username of the user running the current process as a string
- `os.write(fd, buffer)`, which writes the contents of the specified buffer to the specified integer file descriptor and returns the number of bytes written as an integer
- `os.writeFile(path, string)`, which writes the contents of the specified string to the file specified by the path string
    - If the file already exists, it is truncated
- `os.writeFileBin(path, buffer)`, which writes the contents of the specified buffer to the file specified by the path string
    - If the file already exists, it is truncated
