## OS methods and fields

Any method that fails will throw a runtime error with a message describing the error.

The following methods and fields are defined in the built-in `os` class:
- `os.arch`, which is a string that specifies the architecture that the program is running on
- `os.argv`, which is a list containing the command line arguments passed to the current script
    - `os.argv[0]` contains the absolute path name of the executable for the current process as a string or an empty string if the path name cannot be determined
    - When executing a script from a file, `os.argv[1]` contains the name of the script file that is being executed
- `os.chdir(directory)`, which changes the current working directory to the specified directory string
- `os.chmod(path, mode)`, which changes the mode of the specified path string to `mode`
    - This method works on Windows, but only the read-only flag can be changed. Use mode `0400` to make the file read-only and `0600` to make it readable and writable
- `os.chown(path, uid, gid)`, which changes the uid and gid of the specified path string to `uid` and `gid`
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.chroot(path)`, which changes the root directory of the current process to the specified path string
    - This method does not work on Windows and throws an error if called on there
- `os.clearenv()`, which removes all environment variables from the current process
- `os.close(fd)`, which closes the specified integer file descriptor
- `os.closeRange(low, high)`, which closes all file descriptors from `low` to `high` exclusive, ignoring any errors when doing so, where `low` and `high` are integers
- `os.copy(source, dest)`, which copies the file at the `source` path string to the destination specified by the path string `dest` and returns the total number of bytes copied
    - If the file at `source` doesn't exist or `source` refers to a directory, a runtime error is thrown
    - If `dest` refers to a directory, the file at `source` will be copied into the directory given by `dest` with the copied file having the same name as the source file's original name
- `os.dup(oldfd)`, which creates and returns a new file descriptor integer that refers to the file associated with `oldfd`, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.dup2(oldfd, newfd)`, which duplicates the file descriptor `oldfd` to the file descriptor `newfd`, closing `newfd` in the process, where `oldfd` and `newfd` are both integers, and returns the value of `newfd` as an integer
    - If `oldfd == newfd` and `oldfd` is a valid file descriptor, this function does nothing and simply returns the value of `newfd` as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.devFull`, which is a file object that refers to the file `/dev/full` on Unix
    - This field does not exist on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
- `os.devFullBin`, which is a file object that refers to the file `/dev/full` on Unix and is open in binary mode
    - This field does not exist on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
- `os.devNull`, which is a file object that refers to the null device of the current operating system, which is `/dev/null` on Unix and `NUL` on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
- `os.devNullBin`, which is a file object that refers to the null device of the current operating system, which is `/dev/null` on Unix and `NUL` on Windows, and is open in binary mode
    - This field is lazy; the actual file object is only created when this field is accessed
- `os.devRandom`, which is a file object that refers to the file `/dev/random` on Unix
    - This field does not exist on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
    - The file object in this field is open in binary mode
- `os.devUrandom`, which is a file object that refers to the file `/dev/urandom` on Unix
    - This field does not exist on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
    - The file object in this field is open in binary mode
- `os.devZero`, which is a file object that refers to the file `/dev/zero` on Unix
    - This field does not exist on Windows
    - This field is lazy; the actual file object is only created when this field is accessed
    - The file object in this field is open in binary mode
- `os.execl(path, arg1, [arg2, ..., argN])`, which executes the program given by the string argument `path` and the arguments from `arg1` to `argN`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `path`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` are optional
    - This method does not work on Windows and throws an error if called on there
- `os.execle(path, arg1, [arg2, ..., argN], envp)`, which executes the program given by the string argument `path`, the arguments from `arg1` to `argN`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `path` other than `envp`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` except for `envp` are optional
    - This method does not work on Windows and throws an error if called on there
- `os.execlp(file, arg1, [arg2, ..., argN])`, which executes the program given by the string argument `file` and the arguments from `arg1` to `argN`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `file`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` are optional
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.execlpe(file, arg1, [arg2, ..., argN], envp)`, which executes the program given by the string argument `file`, the arguments from `arg1` to `argN`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - All arguments to this method after `file` other than `envp`, which become the command line arguments to the new program, must be strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - `arg1` is required, while all arguments after `arg1` except for `envp` are optional
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.executable()`, which returns the absolute path name of the executable for the current process as a string
- `os.execv(path, argv)`, which executes the program given by the string argument `path` and the list argument `argv`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.execve(path, argv, envp)`, which executes the program given by the string argument `path`, the list argument `argv`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.execvp(file, argv)`, which executes the program given by the string argument `file` and the list argument `argv`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.execvpe(file, argv, envp)`, which executes the program given by the string argument `file`, the list argument `argv`, and the dictionary argument `envp`, immediately replacing the current process on success without returning any value and throwing a runtime error on failure
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.expandEnv(string)`, which returns a new string with all occurrences of `$var` and `${var}` in `string` replaced with the value of `var` itself, where `var` is an environment variable
    - If `var` is not an environment variable, it is replaced with an empty string
- `os.expandHome(string)`, which returns a new string with the characters `~` or `~/` at the beginning of the original string replaced with the path of the user's home directory
    - This method uses the value of the `HOME` environment variable as the home directory on non-Windows systems if it exists
- `os.exit([code])`, which exits the program with the specified exit code. If `code` is omitted, the default exit code is 0
    - Calling this method will immediately stop the program without running any other code, e.g., if this method is called inside a try-catch block with a `finally` block, the `finally` block will not be executed
- `os.fallocate(fd/file/string, size)`, which takes in an integer file descriptor, a file object, or a string that is a path name to a file, followed by a size argument as an integer or string, and if the size of the specified file is less than the size argument, allocates disk space with null bytes to the specified file according to the size argument until its size is the same as the size argument
    - If the size argument is an integer, it specifies the size of the file in bytes
    - If the size argument is a string, it specifies the size of the file as a numerical integer value with a size suffix, which is of the form `"<INTEGER><SUFFIX>"`
        - Examples: `"100M"`, `"1G"`, `"2G"`
        - The following are valid size suffixes:
            - `b`, where `"1b"` is 512 bytes
            - `k`/`K`, where `"1k"` is 1024 bytes
            - `m`/`M`, where `"1m"` is 1024 * 1024 bytes
            - `g`/`G`, where `"1g"` is 1024 * 1024 * 1024 bytes
        - A runtime error is thrown if an invalid string is passed as the size argument
    - If the size argument is equivalent to 0 or a negative value, a runtime error is thrown
    - If a string is specified as the first argument and the file that the string refers to does not exist, it is created
    - If a file descriptor is specified as the first argument and the file corresponding to that file descriptor is not open in write or append mode, this method throws a runtime error with the message "bad file descriptor"
    - On Linux, this method utilizes the `fallocate(2)` syscall and falls back to a generic file allocation method if the syscall fails
        - On non-Linux systems, this method always uses the generic file allocation method
- `os.fchdir(fd)`, which changes the current working directory to the specified directory file descriptor
    - This method does not work on Windows and throws an error if called on there
- `os.fchmod(fd, mode)`, which changes the mode of the specified file descriptor to `mode`
    - This method does not work on Windows and throws an error if called on there
- `os.fchown(fd, uid, gid)`, which changes the uid and gid of the specified file descriptor to `uid` and `gid`
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.forkExec(path, argv)`, which forks a child process and immediately invokes `execv` in the child process with the string argument `path` and the list argument `argv`, returning the pid of the child process as an integer
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.forkExecve(path, argv, envp)`, which forks a child process and immediately invokes `execve` in the child process with the string argument `path`, the list argument `argv`, and the dictionary argument `envp`, returning the pid of the child process as an integer
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - This method does not work on Windows and throws an error if called on there
- `os.forkExecvp(file, argv)`, which forks a child process and immediately invokes `execvp` in the child process with the string argument `file` and the list argument `argv`, returning the pid of the child process as an integer
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.forkExecvpe(file, argv, envp)`, which forks a child process and immediately invokes `execvpe` in the child process with the string argument `file`, the list argument `argv`, and the dictionary argument `envp`, returning the pid of the child process as an integer
    - `argv`, which contains the command line arguments to the new program, must only contain strings or else a runtime error is thrown
    - `envp`, which contains the key-value pairs of environment variables to pass to the new process, must be empty or only contain strings or else a runtime error is thrown
    - The `PATH` environment variable is used when searching for the program to execute
    - This method does not work on Windows and throws an error if called on there
- `os.fsync(fd)`, which forces a write of the file with the specified file descriptor to disk
- `os.ftruncate(fd, size)`, which changes the size of the file specified by the file descriptor integer to `size` bytes specified as an integer
    - If `size` is less than the file size in bytes, the extra data is lost
    - If `size` is greater than the file size in bytes, the file is extended with null bytes until it is equal to `size` bytes
- `os.gc([num])`, which invokes the garbage collector and blocks until the garbage collection process completes
    - If `num` is specified, where `num` is an integer, this method invokes the garbage collector a total of `num` times instead of invoking it only once
- `os.getcwd()`, which returns the current working directory as a string
- `os.getegid()`, which returns the effective group ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getenv(key, [default])`, which returns the value of the specified environment variable `key`, which is a string, as a string. If the value doesn't exist, the value of `default` is returned if specified, otherwise `nil` is returned
- `os.getenvs()`, which returns a dictionary with all environment variable keys as dictionary keys and all environment variable values as dictionary values
- `os.geteuid()`, which returns the effective user ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getgid()`, which returns the group ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.getgroups()`, which returns a list of the supplementary group IDs of the current process as integers
    - This method does not work on Windows and throws an error if called on there
- `os.getpagesize()`, which returns the size of a memory page on the current system in bytes as an integer
- `os.getpid()`, which returns the process ID of the current process as an integer
- `os.getppid()`, which returns the process ID of the parent process as an integer
- `os.getrandom(buffer, [flags])`, which fills the specified buffer with `n` random bytes, where `n` is the length of the buffer, overwriting all existing elements in the buffer with the random bytes, and returns the number of bytes written to the buffer as an integer
    - The optional `flags` argument is an integer and can be equal to `0` or some of the following flag fields bitwise ORed together: `os.GRND_RANDOM`, `os.GRND_NONBLOCK`, `os.GRND_INSECURE`
        - The above flag fields do not exist on non-Linux platforms
        - If `flags` is omitted, it defaults to `0`
    - This method only works on Linux and throws an error if called on any other operating system
- `os.getsid(pid)`, which calls the Unix system call `getsid` with the specified process ID integer and returns the result as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.getuid()`, which returns the user ID of the current process as an integer
    - On Windows, this method always returns `-1`
- `os.hostname()`, which returns the hostname of the computer as a string
- `os.isatty(fd)`, which returns `true` if the specified integer file descriptor is open and refers to a terminal and `false` otherwise
- `os.kill(pid, [signalNum])`, which sends the signal corresponding to the integer `signalNum` to the process corresponding to `pid`, which is the process ID as an integer. If `signalNum` is omitted, this method kills the process corresponding to `pid` without letting it terminate gracefully
- `os.lchown(path, uid, gid)`, which changes the uid and gid of the specified path string to `uid` and `gid`
    - If `path` refers to a symbolic link, the uid and gid of the link itself is changed
    - Passing in `-1` for `uid` or `gid` will result in that uid or gid being unchanged
    - This method does not work on Windows and throws an error if called on there
- `os.link(target, linkName)`, which creates a hard link to `target` with the name `linkName`, which are both strings
- `os.listdir([path])`, which returns a list of names of all directories and files in the specified path as strings. If `path` is omitted, the current working directory is used as the path
- `os.mkdir(name)`, which creates a new directory with the specified name in the current working directory
- `os.mkdirp(path)`, which creates a new directory with the specified path name along with any necessary parent directories
- `os.mkfifo(name)`, which creates a FIFO (named pipe) with the specified name in the current working directory
    - This method does not work on Windows and throws an error if called on there
- `os.mktemp([directory])`, which creates a temporary file with the name `lox.tmp.` followed by a random number in the specified directory and returns a file object open in read-write mode if successful. If the directory is omitted, the temporary file is created in the default temporary file directory of the operating system
    - Any temporary files created using this method must be manually deleted, which can be done with the following method call: `os.remove(tempFile.name)`, where `tempFile` is the variable that refers to the temporary file's file object
- `os.mktempBin([directory])`, which creates a temporary file with the name `lox.tmp.` followed by a random number in the specified directory and returns a file object open in read-write binary mode if successful. If the directory is omitted, the temporary file is created in the default temporary file directory of the operating system
    - Any temporary files created using this method must be manually deleted, which can be done with the following method call: `os.remove(tempFile.name)`, where `tempFile` is the variable that refers to the temporary file's file object
- `os.name`, which is a string that specifies the operating system that the program is running on
- `os.numCPU()`, which returns the number of logical CPUs on the current machine as an integer
- `os.open(name, mode)`, which opens a file specified by a path name with the mode specified by the mode string. This method returns a file object if successful, which itself is documented [here](./doc/file.md)
    - The following file modes are available:
        - `"r"`, which opens a file for reading and throws a runtime error if the file doesn't exist
        - `"w"`, which opens a file for writing, creating the file if it doesn't exist and truncating the file if it already exists
        - `"a"`, which opens a file for writing, creating the file if it doesn't exist and appending to the file if it already exists
        - Along with the above modes, the letter `"b"` can also be specified to open a file in binary mode, such as `"rb"` for reading a binary file
            - The ordering doesn't matter, so the mode `"br"` is the same as `"rb"`
- `os.osarch`, which is a string of the form `"<os.name>/<os.arch>"`
- `os.pipe()`, which returns a list containing two file objects in text mode that are connected to each other through a pipe, where reading from the read end returns data that is written to the write end
    - `list[0]` and `list[1]` contains the read and write ends of the pipe respectively
- `os.pipeBin()`, which returns a list containing two file objects in binary mode that are connected to each other through a pipe, where reading from the read end returns data that is written to the write end
    - `list[0]` and `list[1]` contains the read and write ends of the pipe respectively
- `os.pipefd()`, which creates a pipe and returns a list containing two integers that are file descriptors to that pipe, where `list[0]` refers to the read end and `list[1]` refers to the write end
- `os.process(command, [args...])`, which runs the specified command string with the specified optional argument strings as a separate process and returns the exit code of the command as an integer
    - The `PATH` environment variable is used when searching for the command to execute
- `os.processList(command, [args])`, which runs the specified command string with the specified optional list of argument strings as a separate process and returns the exit code of the command as an integer
    - The optional list argument can be empty, which is the same as omitting the list argument itself
    - The `PATH` environment variable is used when searching for the command to execute
- `os.read(fd, numBytes)`, which reads at most `numBytes` bytes from the specified integer file descriptor into a buffer and returns that buffer
- `os.readFile(name)`, which reads in the contents of the file with the specified file name string and returns a string with the file contents
- `os.readFileBin(name)`, which reads in the contents of the file with the specified file name string and returns a buffer with the file contents
- `os.readLink(name)`, which returns a string representing the destination of the symbolic link with the specified symbolic link name string
- `os.readString(fd, numBytes)`, which reads at most `numBytes` bytes from the specified integer file descriptor into a string and returns that string
- `os.remove(path)`, which removes the file or empty directory at the specified path string
    - If the directory is not empty, a runtime error is thrown
- `os.removeAll(path)`, which removes the file or directory at the specified path string
    - If the directory is not empty, all files and directories inside it are removed recursively
- `os.rename(oldPath, newPath)`, which renames the file at `oldPath` to the name specified by `newPath`, which are both strings. If a file at `newPath` already exists and is not a directory, it is replaced with the file at `oldPath`
- `os.SEEK_SET`, `os.SEEK_CUR`, and `os.SEEK_END`, which are all integer values representing the seek mode for the `file.seek` method
- `os.setegid(egid)`, which sets the effective group ID of the current process to the specified effective group ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setenv(key, value)`, which sets an environment variable with the specified key and value, which are both strings
- `os.seteuid(euid)`, which sets the effective user ID of the current process to the specified effective user ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setgid(gid)`, which sets the group ID of the current process to the specified group ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setgroups(gids)`, which sets the supplementary group IDs for the current process to the values in `gids`, which must be an empty list or a list of integers
    - This method does not work on Windows and throws an error if called on there
- `os.setregid(rgid, egid)`, which sets the group ID and effective group ID of the current process to the specified group ID and effective group ID, which are both integers
    - Passing in `-1` for `rgid` or `egid` will result in the group ID or the effective group ID being unchanged respectively
    - This method does not work on Windows and throws an error if called on there
- `os.setresgid(rgid, egid, sgid)`, which sets the group ID, effective group ID, and saved group ID of the current process to the specified group ID, effective group ID, and saved group ID, which are all integers
    - Passing in `-1` for `rgid`, `egid`, or `sgid` will result in the group ID, the effective group ID, or the saved group ID being unchanged respectively
    - This method only works on Linux and throws an error if called on any other operating system
- `os.setresuid(ruid, euid, suid)`, which sets the user ID, effective user ID, and saved user ID of the current process to the specified user ID, effective user ID, and saved user ID, which are all integers
    - Passing in `-1` for `ruid`, `euid`, or `suid` will result in the user ID, the effective user ID, or the saved user ID being unchanged respectively
    - This method only works on Linux and throws an error if called on any other operating system
- `os.setreuid(ruid, euid)`, which sets the user ID and effective user ID of the current process to the specified user ID and effective user ID, which are both integers
    - Passing in `-1` for `ruid` or `euid` will result in the user ID or the effective user ID being unchanged respectively
    - This method does not work on Windows and throws an error if called on there
- `os.setsid()`, which calls the Unix system call `setsid` and returns the result as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.setuid(uid)`, which sets the user ID of the current process to the specified user ID, which is an integer
    - This method does not work on Windows and throws an error if called on there
- `os.stderr`, which is a file object that allows for writing text to the standard error stream
- `os.stdin`, which is a file object that allows for reading text from the standard input stream
- `os.stdout`, which is a file object that allows for writing text to the standard output stream
- `os.stderrBin`, which is a file object that allows for writing binary data to the standard error stream
- `os.stdinBin`, which is a file object that allows for reading binary data from the standard input stream
- `os.stdoutBin`, which is a file object that allows for writing binary data to the standard output stream
- `os.symlink(target, linkName)`, which creates a symbolic link to `target` with the name `linkName`, which are both strings
- `os.sync()`, which forces a write of all data to disk
    - This method does not work on Windows and throws an error if called on there
- `os.sysinfo()`, which returns a dictionary containing information about memory and swap usage on Linux via the `sysinfo(2)` syscall
    - The returned dictionary contains the following keys and values, where the keys are all strings:
        - `uptime` (integer)
        - `loads` (list)
        - `totalram` (integer)
        - `freeram` (integer)
        - `sharedram` (integer)
        - `bufferram` (integer)
        - `totalswap` (integer)
        - `freeswap` (integer)
        - `procs` (integer)
        - `totalhigh` (integer)
        - `freehigh` (integer)
        - `unit` (integer)
    - This method only works on Linux and throws an error if called on any other operating system
- `os.system(command)`, which runs the specified command string in the system shell, which is `sh` on Unix and `cmd` on Windows, and returns the exit code of the command as an integer
- `os.tee(arg, path)`, which writes the string representation of the specified argument to the file specified by the path name and also writes the string to standard output
    - If the file already exists, it is truncated
- `os.teeAppend(arg, path)`, which appends the string representation of the specified argument to the file specified by the path name and also writes the string to standard output
- `os.tempdir()`, which returns the path of the default temporary file directory of the operating system as a string
- `os.touch(name)`, which creates a new empty file with the specified name in the current working directory
    - If the file already exists, it is truncated
- `os.truncate(path, size)`, which changes the size of the file specified by the path string to `size` bytes specified as an integer
    - If `size` is less than the file size in bytes, the extra data is lost
    - If `size` is greater than the file size in bytes, the file is extended with null bytes until it is equal to `size` bytes
- `os.umask(mask)`, which sets the current umask value to the integer `mask` and returns the previous umask value as an integer
    - This method does not work on Windows and throws an error if called on there
- `os.uname()`, which returns a dictionary containing information about the current Unix operating system
    - The returned dictionary contains the following keys and values, which are all strings:
        - `sysname`: name of the operating system
        - `nodename`: name of the current machine on the network
        - `release`: release of the operating system
        - `version`: version of the operating system
        - `machine`: architecture of the current machine
    - This method does not work on Windows and throws an error if called on there
- `os.unsetenv(key)`, which unsets the environment variable `key`, which is a string
- `os.urandom(size)`, which returns a buffer of `size` random bytes that are cryptographically secure, where `size` is an integer
    - If `size` is negative, a runtime error is thrown
- `os.userCacheDir()`, which returns the path of the directory to be used for storing user-specific cached data as a string
- `os.userConfigDir()`, which returns the path of the directory to be used for storing user-specific configuration data as a string
- `os.userHomeDir()`, which returns the path of the user's home directory as a string
- `os.username()`, which returns the username of the user running the current process as a string
    - On Windows, if the username contains backslashes, this method only returns the part of the username after the last backslash
- `os.usernameFull()`, which returns the username of the user running the current process as a string
    - On Windows, this method always returns the full username
- `os.wait()`, which waits for a child process to complete and returns a list containing the pid of the completed child process as an integer and a wait status object with various methods that are used to obtain information regarding the completed child process, which are documented [here](./waitstatus.md)
    - This method does not work on Windows and throws an error if called on there
- `os.whoami()`, which invokes the `whoami` executable located at `C:\Windows\System32\whoami.exe` on Windows and `/bin/whoami` on Unix and returns a string that contains the standard output of that executable with all trailing newline characters and spaces removed
    - If the initial `whoami` executable is not found, this method searches the `PATH` environment variable for an executable called `whoami` and executes that instead
- `os.write(fd, buffer)`, which writes the contents of the specified buffer to the specified integer file descriptor and returns the number of bytes written as an integer
- `os.writeFile(path, string)`, which writes the contents of the specified string to the file specified by the path string
    - If the file already exists, it is truncated
- `os.writeFileBin(path, buffer)`, which writes the contents of the specified buffer to the file specified by the path string
    - If the file already exists, it is truncated
- `os.writeString(fd, string)`, which writes the contents of the specified string to the specified integer file descriptor and returns the number of bytes written as an integer
